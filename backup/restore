#!/usr/bin/env bash

## Restore from a backup
set -eE

volumes=("hint_db_data" "hint_redis_data" "hint_prerun" "hint_results" "hint_uploads" "hint_config")

array_contains() {
    local seeking=$1
    shift
    local in=1
    for element; do
        if [[ $element == "$seeking" ]]; then
            in=0
            break
        fi
    done
    return $in
}

assert_file_exists() {
    if !([ ! -z "$1" ] && [ -f "$1" ]); then
        echo "Backup dir $1 does not exist"
        echo "Usage: restore <backup_dir>"
        exit 1
    fi
}

assert_all_data_exists() {
    if !([ ! -z "$1" ] && [ -d "$1" ] && [ -f "$1/db_dump.sql" ] && [ -f "$1/redis_backup.tar" ] &&
        [ -f "$1/prerun_backup.tar" ] && [ -f "$1/results_backup.tar" ] && [ -f "$1/uploads_backup.tar" ]); then
        echo "Backup dir $1 is incomplete"
        echo "Usage: restore <backup_dir>"
        exit 1
    fi
}

create_volumes() {
    existing_volumes=($(docker volume ls --format '{{.Name}}'))
    for volume in ${volumes[@]}; do
        if array_contains "$volume" "${existing_volumes[@]}"; then
            echo "Volume '${volume}' already exists, remove volume before running restore"
            exit 1
        fi
    done
    for volume in ${volumes[@]}; do
        echo "Creating volume ${volume}"
        docker volume create ${volume}
    done
}

restore() {
    create_volumes
    docker run --rm -d -v hint_db_data:/pgdata -e POSTGRES_PASSWORD=password -e PGDATA=/pgdata --name restore_pg postgres:10.3
    sleep 5 ## Ideally here we would do something cleverer and poll for db being ready to accept connections
    docker exec -i restore_pg psql -U postgres postgres <$1/db_dump.sql
    docker stop restore_pg
    docker run --rm -v hint_redis_data:/data -v $1:/backup busybox tar -xvf /backup/redis_backup.tar -C /data
    docker run --rm -v hint_prerun:/data -v $1:/backup busybox tar -xvf /backup/prerun_backup.tar -C /data
    docker run --rm -v hint_results:/data -v $1:/backup busybox tar -xvf /backup/results_backup.tar -C /data
    docker run --rm -v hint_uploads:/data -v $1:/backup busybox tar -xvf /backup/uploads_backup.tar -C /data
}

restore_key() {
    VAULT_PATH=$(cat $RESTORE_WORKING_DIR/cipher_path)
    echo "Restoring keys from vault path '$VAULT_PATH'"
    VAULT_ADDR="https://vault.dide.ic.ac.uk:8200"
    vault login -address=$VAULT_ADDR -method=github
    PUBLIC_KEY=$(vault read -field=public $VAULT_PATH | base64 --decode --ignore-garbage)
    PRIVATE_KEY=$(vault read -field=private $VAULT_PATH | base64 --decode --ignore-garbage)
    docker run --rm -v hint_config:/data busybox sh -c \
        "mkdir /data/token_key && echo $PUBLIC_KEY >/data/token_key/public_key.der && echo $PRIVATE_KEY >/data/token_key/private_key.der"
}

assert_file_exists $1
RESTORE_DIR="$(
    cd "$(dirname "$1")"
    pwd
)"
RESTORE_PATH=$RESTORE_DIR/$(basename "$1")
RESTORE_WORKING_DIR=$RESTORE_DIR/working
mkdir $RESTORE_WORKING_DIR
clean_up() {
    echo "Restore failed, cleaning up working dir"
    rm -rf $RESTORE_WORKING_DIR
    docker stop restore_pg || true
    docker rm helper || true
    exit 1
}
trap clean_up ERR

tar -xvf $1 -C $RESTORE_WORKING_DIR
md5sum --check $RESTORE_WORKING_DIR/checklist.chk
assert_all_data_exists $RESTORE_WORKING_DIR
restore $RESTORE_WORKING_DIR
if [ -f "$RESTORE_WORKING_DIR/cipher_path" ]; then
    echo "Do you want to restore cipher keys from vault?"
    read -p "Restore keys? y/n" -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        restore_key
    fi
fi

echo "Restore complete"
rm -rf $RESTORE_WORKING_DIR
